/**
 * Site Bay
 *
 * OpenAPI schema for the Agency plan. Access for only $99USD per month! Swagger docs available at https://my.sitebay.org/docs
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException

import org.openapitools.client.models.ExternalPathCreate
import org.openapitools.client.models.HTTPValidationError
import org.openapitools.client.models.PITRestoreCreate
import org.openapitools.client.models.SiteLive
import org.openapitools.client.models.SiteLiveCreate
import org.openapitools.client.models.SiteLiveUpdate
import org.openapitools.client.models.SiteStageCreate
import org.openapitools.client.models.Tag
import org.openapitools.client.models.TagCreate
import org.openapitools.client.models.UNKNOWN_BASE_TYPE
import org.openapitools.client.models.UserEmailCreate
import org.openapitools.client.models.UserEmailUpdate

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class SiteLiveApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://my.sitebay.org")
        }
    }

    /**
    * Create Email DNS records
    * Automatically add the DNS records to your Nameserver configured site
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addMailDns(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = addMailDnsWithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create Email DNS records
    * Automatically add the DNS records to your Nameserver configured site
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addMailDnsWithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = addMailDnsRequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation addMailDns
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun addMailDnsRequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/dns/email_dns_records".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create Email DNS records
    * Automatically add the DNS records to your Nameserver configured site
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addMailDns_0(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = addMailDns_0WithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create Email DNS records
    * Automatically add the DNS records to your Nameserver configured site
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addMailDns_0WithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = addMailDns_0RequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation addMailDns_0
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun addMailDns_0RequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/dns/email_dns_records".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Change HTTP Auth
    * Enable or disable HTTP Basic Authentication
    * @param fqdn  
    * @param `value`  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun changeDevMode(fqdn: kotlin.String, `value`: kotlin.String) : kotlin.Any {
        val localVarResponse = changeDevModeWithHttpInfo(fqdn = fqdn, `value` = `value`)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Change HTTP Auth
    * Enable or disable HTTP Basic Authentication
    * @param fqdn  
    * @param `value`  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun changeDevModeWithHttpInfo(fqdn: kotlin.String, `value`: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = changeDevModeRequestConfig(fqdn = fqdn, `value` = `value`)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation changeDevMode
    *
    * @param fqdn  
    * @param `value`  
    * @return RequestConfig
    */
    fun changeDevModeRequestConfig(fqdn: kotlin.String, `value`: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("value", listOf(`value`.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v1/site_live/{fqdn}/change-dev-mode".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Change HTTP Auth
    * Enable or disable HTTP Basic Authentication
    * @param fqdn  
    * @param `value`  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun changeDevMode_0(fqdn: kotlin.String, `value`: kotlin.String) : kotlin.Any {
        val localVarResponse = changeDevMode_0WithHttpInfo(fqdn = fqdn, `value` = `value`)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Change HTTP Auth
    * Enable or disable HTTP Basic Authentication
    * @param fqdn  
    * @param `value`  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun changeDevMode_0WithHttpInfo(fqdn: kotlin.String, `value`: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = changeDevMode_0RequestConfig(fqdn = fqdn, `value` = `value`)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation changeDevMode_0
    *
    * @param fqdn  
    * @param `value`  
    * @return RequestConfig
    */
    fun changeDevMode_0RequestConfig(fqdn: kotlin.String, `value`: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("value", listOf(`value`.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v1/site_live/{fqdn}/change-dev-mode".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Clear the cache
    * Purges the Cloudflare CDN cache for your site
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clearCache(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = clearCacheWithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Clear the cache
    * Purges the Cloudflare CDN cache for your site
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun clearCacheWithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = clearCacheRequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation clearCache
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun clearCacheRequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/clear-cache".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Clear the cache
    * Purges the Cloudflare CDN cache for your site
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clearCache_0(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = clearCache_0WithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Clear the cache
    * Purges the Cloudflare CDN cache for your site
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun clearCache_0WithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = clearCache_0RequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation clearCache_0
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun clearCache_0RequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/clear-cache".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Commit Stage Site
    * Sync the wp-content and database from your staging site to your live site
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun commitSiteStage(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = commitSiteStageWithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Commit Stage Site
    * Sync the wp-content and database from your staging site to your live site
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun commitSiteStageWithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = commitSiteStageRequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation commitSiteStage
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun commitSiteStageRequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/stage/commit".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Commit Stage Site
    * Sync the wp-content and database from your staging site to your live site
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun commitSiteStage_0(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = commitSiteStage_0WithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Commit Stage Site
    * Sync the wp-content and database from your staging site to your live site
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun commitSiteStage_0WithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = commitSiteStage_0RequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation commitSiteStage_0
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun commitSiteStage_0RequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/stage/commit".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create Email
    * Create a custom email account
    * @param fqdn  
    * @param userEmailCreate  (optional)
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createEmail(fqdn: kotlin.String, userEmailCreate: UserEmailCreate?) : kotlin.Any {
        val localVarResponse = createEmailWithHttpInfo(fqdn = fqdn, userEmailCreate = userEmailCreate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create Email
    * Create a custom email account
    * @param fqdn  
    * @param userEmailCreate  (optional)
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createEmailWithHttpInfo(fqdn: kotlin.String, userEmailCreate: UserEmailCreate?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = createEmailRequestConfig(fqdn = fqdn, userEmailCreate = userEmailCreate)

        return request<UserEmailCreate, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation createEmail
    *
    * @param fqdn  
    * @param userEmailCreate  (optional)
    * @return RequestConfig
    */
    fun createEmailRequestConfig(fqdn: kotlin.String, userEmailCreate: UserEmailCreate?) : RequestConfig<UserEmailCreate> {
        val localVariableBody = userEmailCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/email".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create Email
    * Create a custom email account
    * @param fqdn  
    * @param userEmailCreate  (optional)
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createEmail_0(fqdn: kotlin.String, userEmailCreate: UserEmailCreate?) : kotlin.Any {
        val localVarResponse = createEmail_0WithHttpInfo(fqdn = fqdn, userEmailCreate = userEmailCreate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create Email
    * Create a custom email account
    * @param fqdn  
    * @param userEmailCreate  (optional)
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createEmail_0WithHttpInfo(fqdn: kotlin.String, userEmailCreate: UserEmailCreate?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = createEmail_0RequestConfig(fqdn = fqdn, userEmailCreate = userEmailCreate)

        return request<UserEmailCreate, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation createEmail_0
    *
    * @param fqdn  
    * @param userEmailCreate  (optional)
    * @return RequestConfig
    */
    fun createEmail_0RequestConfig(fqdn: kotlin.String, userEmailCreate: UserEmailCreate?) : RequestConfig<UserEmailCreate> {
        val localVariableBody = userEmailCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/email".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create External Path
    * Connect an external URL to your site on a subpath
    * @param fqdn  
    * @param externalPathCreate  (optional)
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createExternalPath(fqdn: kotlin.String, externalPathCreate: ExternalPathCreate?) : kotlin.Any {
        val localVarResponse = createExternalPathWithHttpInfo(fqdn = fqdn, externalPathCreate = externalPathCreate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create External Path
    * Connect an external URL to your site on a subpath
    * @param fqdn  
    * @param externalPathCreate  (optional)
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createExternalPathWithHttpInfo(fqdn: kotlin.String, externalPathCreate: ExternalPathCreate?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = createExternalPathRequestConfig(fqdn = fqdn, externalPathCreate = externalPathCreate)

        return request<ExternalPathCreate, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation createExternalPath
    *
    * @param fqdn  
    * @param externalPathCreate  (optional)
    * @return RequestConfig
    */
    fun createExternalPathRequestConfig(fqdn: kotlin.String, externalPathCreate: ExternalPathCreate?) : RequestConfig<ExternalPathCreate> {
        val localVariableBody = externalPathCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/external-path".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create External Path
    * Connect an external URL to your site on a subpath
    * @param fqdn  
    * @param externalPathCreate  (optional)
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createExternalPath_0(fqdn: kotlin.String, externalPathCreate: ExternalPathCreate?) : kotlin.Any {
        val localVarResponse = createExternalPath_0WithHttpInfo(fqdn = fqdn, externalPathCreate = externalPathCreate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create External Path
    * Connect an external URL to your site on a subpath
    * @param fqdn  
    * @param externalPathCreate  (optional)
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createExternalPath_0WithHttpInfo(fqdn: kotlin.String, externalPathCreate: ExternalPathCreate?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = createExternalPath_0RequestConfig(fqdn = fqdn, externalPathCreate = externalPathCreate)

        return request<ExternalPathCreate, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation createExternalPath_0
    *
    * @param fqdn  
    * @param externalPathCreate  (optional)
    * @return RequestConfig
    */
    fun createExternalPath_0RequestConfig(fqdn: kotlin.String, externalPathCreate: ExternalPathCreate?) : RequestConfig<ExternalPathCreate> {
        val localVariableBody = externalPathCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/external-path".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create a site
    * Create a new site by providing your domain and your site&#39;s WordPress details
    * @param UNKNOWN_BASE_TYPE  (optional)
    * @return SiteLive
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createSiteLive(UNKNOWN_BASE_TYPE: UNKNOWN_BASE_TYPE?) : SiteLive {
        val localVarResponse = createSiteLiveWithHttpInfo(UNKNOWN_BASE_TYPE = UNKNOWN_BASE_TYPE)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SiteLive
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create a site
    * Create a new site by providing your domain and your site&#39;s WordPress details
    * @param UNKNOWN_BASE_TYPE  (optional)
    * @return ApiResponse<SiteLive?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createSiteLiveWithHttpInfo(UNKNOWN_BASE_TYPE: UNKNOWN_BASE_TYPE?) : ApiResponse<SiteLive?> {
        val localVariableConfig = createSiteLiveRequestConfig(UNKNOWN_BASE_TYPE = UNKNOWN_BASE_TYPE)

        return request<UNKNOWN_BASE_TYPE, SiteLive>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation createSiteLive
    *
    * @param UNKNOWN_BASE_TYPE  (optional)
    * @return RequestConfig
    */
    fun createSiteLiveRequestConfig(UNKNOWN_BASE_TYPE: UNKNOWN_BASE_TYPE?) : RequestConfig<UNKNOWN_BASE_TYPE> {
        val localVariableBody = UNKNOWN_BASE_TYPE
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create a site
    * Create a new site by providing your domain and your site&#39;s WordPress details
    * @param UNKNOWN_BASE_TYPE  (optional)
    * @return SiteLive
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createSiteLive_0(UNKNOWN_BASE_TYPE: UNKNOWN_BASE_TYPE?) : SiteLive {
        val localVarResponse = createSiteLive_0WithHttpInfo(UNKNOWN_BASE_TYPE = UNKNOWN_BASE_TYPE)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SiteLive
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create a site
    * Create a new site by providing your domain and your site&#39;s WordPress details
    * @param UNKNOWN_BASE_TYPE  (optional)
    * @return ApiResponse<SiteLive?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createSiteLive_0WithHttpInfo(UNKNOWN_BASE_TYPE: UNKNOWN_BASE_TYPE?) : ApiResponse<SiteLive?> {
        val localVariableConfig = createSiteLive_0RequestConfig(UNKNOWN_BASE_TYPE = UNKNOWN_BASE_TYPE)

        return request<UNKNOWN_BASE_TYPE, SiteLive>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation createSiteLive_0
    *
    * @param UNKNOWN_BASE_TYPE  (optional)
    * @return RequestConfig
    */
    fun createSiteLive_0RequestConfig(UNKNOWN_BASE_TYPE: UNKNOWN_BASE_TYPE?) : RequestConfig<UNKNOWN_BASE_TYPE> {
        val localVariableBody = UNKNOWN_BASE_TYPE
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create a Staging site
    * Create a staging site on which you can test changes
    * @param fqdn  
    * @param siteStageCreate  (optional)
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createSiteStage(fqdn: kotlin.String, siteStageCreate: SiteStageCreate?) : kotlin.Any {
        val localVarResponse = createSiteStageWithHttpInfo(fqdn = fqdn, siteStageCreate = siteStageCreate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create a Staging site
    * Create a staging site on which you can test changes
    * @param fqdn  
    * @param siteStageCreate  (optional)
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createSiteStageWithHttpInfo(fqdn: kotlin.String, siteStageCreate: SiteStageCreate?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = createSiteStageRequestConfig(fqdn = fqdn, siteStageCreate = siteStageCreate)

        return request<SiteStageCreate, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation createSiteStage
    *
    * @param fqdn  
    * @param siteStageCreate  (optional)
    * @return RequestConfig
    */
    fun createSiteStageRequestConfig(fqdn: kotlin.String, siteStageCreate: SiteStageCreate?) : RequestConfig<SiteStageCreate> {
        val localVariableBody = siteStageCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/stage".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create a Staging site
    * Create a staging site on which you can test changes
    * @param fqdn  
    * @param siteStageCreate  (optional)
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createSiteStage_0(fqdn: kotlin.String, siteStageCreate: SiteStageCreate?) : kotlin.Any {
        val localVarResponse = createSiteStage_0WithHttpInfo(fqdn = fqdn, siteStageCreate = siteStageCreate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create a Staging site
    * Create a staging site on which you can test changes
    * @param fqdn  
    * @param siteStageCreate  (optional)
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createSiteStage_0WithHttpInfo(fqdn: kotlin.String, siteStageCreate: SiteStageCreate?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = createSiteStage_0RequestConfig(fqdn = fqdn, siteStageCreate = siteStageCreate)

        return request<SiteStageCreate, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation createSiteStage_0
    *
    * @param fqdn  
    * @param siteStageCreate  (optional)
    * @return RequestConfig
    */
    fun createSiteStage_0RequestConfig(fqdn: kotlin.String, siteStageCreate: SiteStageCreate?) : RequestConfig<SiteStageCreate> {
        val localVariableBody = siteStageCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/stage".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create tag
    * Create a tag for organizational purposes for your site
    * @param fqdn  
    * @param tagCreate  (optional)
    * @return Tag
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createTag(fqdn: kotlin.String, tagCreate: TagCreate?) : Tag {
        val localVarResponse = createTagWithHttpInfo(fqdn = fqdn, tagCreate = tagCreate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Tag
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create tag
    * Create a tag for organizational purposes for your site
    * @param fqdn  
    * @param tagCreate  (optional)
    * @return ApiResponse<Tag?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createTagWithHttpInfo(fqdn: kotlin.String, tagCreate: TagCreate?) : ApiResponse<Tag?> {
        val localVariableConfig = createTagRequestConfig(fqdn = fqdn, tagCreate = tagCreate)

        return request<TagCreate, Tag>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation createTag
    *
    * @param fqdn  
    * @param tagCreate  (optional)
    * @return RequestConfig
    */
    fun createTagRequestConfig(fqdn: kotlin.String, tagCreate: TagCreate?) : RequestConfig<TagCreate> {
        val localVariableBody = tagCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/tag".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create tag
    * Create a tag for organizational purposes for your site
    * @param fqdn  
    * @param tagCreate  (optional)
    * @return Tag
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createTag_0(fqdn: kotlin.String, tagCreate: TagCreate?) : Tag {
        val localVarResponse = createTag_0WithHttpInfo(fqdn = fqdn, tagCreate = tagCreate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Tag
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create tag
    * Create a tag for organizational purposes for your site
    * @param fqdn  
    * @param tagCreate  (optional)
    * @return ApiResponse<Tag?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createTag_0WithHttpInfo(fqdn: kotlin.String, tagCreate: TagCreate?) : ApiResponse<Tag?> {
        val localVariableConfig = createTag_0RequestConfig(fqdn = fqdn, tagCreate = tagCreate)

        return request<TagCreate, Tag>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation createTag_0
    *
    * @param fqdn  
    * @param tagCreate  (optional)
    * @return RequestConfig
    */
    fun createTag_0RequestConfig(fqdn: kotlin.String, tagCreate: TagCreate?) : RequestConfig<TagCreate> {
        val localVariableBody = tagCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/tag".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delete DNS record
    * Delete a DNS record on your Nameserver configured site
    * @param dnsId  
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteDnsRecord(dnsId: kotlin.String, fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = deleteDnsRecordWithHttpInfo(dnsId = dnsId, fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Delete DNS record
    * Delete a DNS record on your Nameserver configured site
    * @param dnsId  
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteDnsRecordWithHttpInfo(dnsId: kotlin.String, fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deleteDnsRecordRequestConfig(dnsId = dnsId, fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deleteDnsRecord
    *
    * @param dnsId  
    * @param fqdn  
    * @return RequestConfig
    */
    fun deleteDnsRecordRequestConfig(dnsId: kotlin.String, fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/site_live/{fqdn}/dns/{dns_id}".replace("{"+"dns_id"+"}", "$dnsId").replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delete DNS record
    * Delete a DNS record on your Nameserver configured site
    * @param dnsId  
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteDnsRecord_0(dnsId: kotlin.String, fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = deleteDnsRecord_0WithHttpInfo(dnsId = dnsId, fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Delete DNS record
    * Delete a DNS record on your Nameserver configured site
    * @param dnsId  
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteDnsRecord_0WithHttpInfo(dnsId: kotlin.String, fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deleteDnsRecord_0RequestConfig(dnsId = dnsId, fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deleteDnsRecord_0
    *
    * @param dnsId  
    * @param fqdn  
    * @return RequestConfig
    */
    fun deleteDnsRecord_0RequestConfig(dnsId: kotlin.String, fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/site_live/{fqdn}/dns/{dns_id}".replace("{"+"dns_id"+"}", "$dnsId").replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delete Email
    * Delete a custom email account
    * @param fqdn  
    * @param userEmailAddress  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteEmail(fqdn: kotlin.String, userEmailAddress: kotlin.String) : kotlin.Any {
        val localVarResponse = deleteEmailWithHttpInfo(fqdn = fqdn, userEmailAddress = userEmailAddress)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Delete Email
    * Delete a custom email account
    * @param fqdn  
    * @param userEmailAddress  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteEmailWithHttpInfo(fqdn: kotlin.String, userEmailAddress: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deleteEmailRequestConfig(fqdn = fqdn, userEmailAddress = userEmailAddress)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deleteEmail
    *
    * @param fqdn  
    * @param userEmailAddress  
    * @return RequestConfig
    */
    fun deleteEmailRequestConfig(fqdn: kotlin.String, userEmailAddress: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/site_live/{fqdn}/email/{user_email_address}".replace("{"+"fqdn"+"}", "$fqdn").replace("{"+"user_email_address"+"}", "$userEmailAddress"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delete Email
    * Delete a custom email account
    * @param fqdn  
    * @param userEmailAddress  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteEmail_0(fqdn: kotlin.String, userEmailAddress: kotlin.String) : kotlin.Any {
        val localVarResponse = deleteEmail_0WithHttpInfo(fqdn = fqdn, userEmailAddress = userEmailAddress)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Delete Email
    * Delete a custom email account
    * @param fqdn  
    * @param userEmailAddress  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteEmail_0WithHttpInfo(fqdn: kotlin.String, userEmailAddress: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deleteEmail_0RequestConfig(fqdn = fqdn, userEmailAddress = userEmailAddress)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deleteEmail_0
    *
    * @param fqdn  
    * @param userEmailAddress  
    * @return RequestConfig
    */
    fun deleteEmail_0RequestConfig(fqdn: kotlin.String, userEmailAddress: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/site_live/{fqdn}/email/{user_email_address}".replace("{"+"fqdn"+"}", "$fqdn").replace("{"+"user_email_address"+"}", "$userEmailAddress"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delete External Path
    * Delete the link between an external URL and your site
    * @param externalPathId  
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteExternalPath(externalPathId: kotlin.String, fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = deleteExternalPathWithHttpInfo(externalPathId = externalPathId, fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Delete External Path
    * Delete the link between an external URL and your site
    * @param externalPathId  
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteExternalPathWithHttpInfo(externalPathId: kotlin.String, fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deleteExternalPathRequestConfig(externalPathId = externalPathId, fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deleteExternalPath
    *
    * @param externalPathId  
    * @param fqdn  
    * @return RequestConfig
    */
    fun deleteExternalPathRequestConfig(externalPathId: kotlin.String, fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/site_live/{fqdn}/external-path/{external_path_id}".replace("{"+"external_path_id"+"}", "$externalPathId").replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delete External Path
    * Delete the link between an external URL and your site
    * @param externalPathId  
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteExternalPath_0(externalPathId: kotlin.String, fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = deleteExternalPath_0WithHttpInfo(externalPathId = externalPathId, fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Delete External Path
    * Delete the link between an external URL and your site
    * @param externalPathId  
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteExternalPath_0WithHttpInfo(externalPathId: kotlin.String, fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deleteExternalPath_0RequestConfig(externalPathId = externalPathId, fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deleteExternalPath_0
    *
    * @param externalPathId  
    * @param fqdn  
    * @return RequestConfig
    */
    fun deleteExternalPath_0RequestConfig(externalPathId: kotlin.String, fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/site_live/{fqdn}/external-path/{external_path_id}".replace("{"+"external_path_id"+"}", "$externalPathId").replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delete your live site
    * This permanently deletes your site, and its stage site if one exists
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteSiteLive(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = deleteSiteLiveWithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Delete your live site
    * This permanently deletes your site, and its stage site if one exists
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteSiteLiveWithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deleteSiteLiveRequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deleteSiteLive
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun deleteSiteLiveRequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/site_live/{fqdn}".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delete your live site
    * This permanently deletes your site, and its stage site if one exists
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteSiteLive_0(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = deleteSiteLive_0WithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Delete your live site
    * This permanently deletes your site, and its stage site if one exists
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteSiteLive_0WithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deleteSiteLive_0RequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deleteSiteLive_0
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun deleteSiteLive_0RequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/site_live/{fqdn}".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delete Stage Site
    * Delete your staging site
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteSiteStage(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = deleteSiteStageWithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Delete Stage Site
    * Delete your staging site
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteSiteStageWithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deleteSiteStageRequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deleteSiteStage
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun deleteSiteStageRequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/site_live/{fqdn}/stage".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delete Stage Site
    * Delete your staging site
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteSiteStage_0(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = deleteSiteStage_0WithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Delete Stage Site
    * Delete your staging site
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteSiteStage_0WithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deleteSiteStage_0RequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deleteSiteStage_0
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun deleteSiteStage_0RequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/site_live/{fqdn}/stage".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a tag
    * Get a tag by its ID
    * @param tagId  
    * @param fqdn  
    * @return kotlin.collections.List<Tag>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteTag(tagId: kotlin.String, fqdn: kotlin.String) : kotlin.collections.List<Tag> {
        val localVarResponse = deleteTagWithHttpInfo(tagId = tagId, fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Tag>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get a tag
    * Get a tag by its ID
    * @param tagId  
    * @param fqdn  
    * @return ApiResponse<kotlin.collections.List<Tag>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteTagWithHttpInfo(tagId: kotlin.String, fqdn: kotlin.String) : ApiResponse<kotlin.collections.List<Tag>?> {
        val localVariableConfig = deleteTagRequestConfig(tagId = tagId, fqdn = fqdn)

        return request<Unit, kotlin.collections.List<Tag>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deleteTag
    *
    * @param tagId  
    * @param fqdn  
    * @return RequestConfig
    */
    fun deleteTagRequestConfig(tagId: kotlin.String, fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/site_live/{fqdn}/tag/{tag_id}".replace("{"+"tag_id"+"}", "$tagId").replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a tag
    * Get a tag by its ID
    * @param tagId  
    * @param fqdn  
    * @return kotlin.collections.List<Tag>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteTag_0(tagId: kotlin.String, fqdn: kotlin.String) : kotlin.collections.List<Tag> {
        val localVarResponse = deleteTag_0WithHttpInfo(tagId = tagId, fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Tag>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get a tag
    * Get a tag by its ID
    * @param tagId  
    * @param fqdn  
    * @return ApiResponse<kotlin.collections.List<Tag>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteTag_0WithHttpInfo(tagId: kotlin.String, fqdn: kotlin.String) : ApiResponse<kotlin.collections.List<Tag>?> {
        val localVariableConfig = deleteTag_0RequestConfig(tagId = tagId, fqdn = fqdn)

        return request<Unit, kotlin.collections.List<Tag>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deleteTag_0
    *
    * @param tagId  
    * @param fqdn  
    * @return RequestConfig
    */
    fun deleteTag_0RequestConfig(tagId: kotlin.String, fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/site_live/{fqdn}/tag/{tag_id}".replace("{"+"tag_id"+"}", "$tagId").replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Disable the firewall
    * Disable wp-login firewall
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun disableFirewall(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = disableFirewallWithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Disable the firewall
    * Disable wp-login firewall
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun disableFirewallWithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = disableFirewallRequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation disableFirewall
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun disableFirewallRequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/site_live/{fqdn}/firewall".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Disable the firewall
    * Disable wp-login firewall
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun disableFirewall_0(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = disableFirewall_0WithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Disable the firewall
    * Disable wp-login firewall
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun disableFirewall_0WithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = disableFirewall_0RequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation disableFirewall_0
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun disableFirewall_0RequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/site_live/{fqdn}/firewall".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Enable the firewall
    * Enable the wp-login firewall
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun enableFirewall(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = enableFirewallWithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Enable the firewall
    * Enable the wp-login firewall
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun enableFirewallWithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = enableFirewallRequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation enableFirewall
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun enableFirewallRequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/firewall".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Enable the firewall
    * Enable the wp-login firewall
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun enableFirewall_0(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = enableFirewall_0WithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Enable the firewall
    * Enable the wp-login firewall
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun enableFirewall_0WithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = enableFirewall_0RequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation enableFirewall_0
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun enableFirewall_0RequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/firewall".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get DNS records
    * Get a nameserver configured site&#39;s DNS records
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getDnsRecords(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = getDnsRecordsWithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get DNS records
    * Get a nameserver configured site&#39;s DNS records
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getDnsRecordsWithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getDnsRecordsRequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getDnsRecords
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun getDnsRecordsRequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/dns".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get DNS records
    * Get a nameserver configured site&#39;s DNS records
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getDnsRecords_0(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = getDnsRecords_0WithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get DNS records
    * Get a nameserver configured site&#39;s DNS records
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getDnsRecords_0WithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getDnsRecords_0RequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getDnsRecords_0
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun getDnsRecords_0RequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/dns".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Emails
    * Get all custom email accounts
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEmails(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = getEmailsWithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get Emails
    * Get all custom email accounts
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEmailsWithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getEmailsRequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getEmails
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun getEmailsRequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/email".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Emails
    * Get all custom email accounts
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEmails_0(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = getEmails_0WithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get Emails
    * Get all custom email accounts
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEmails_0WithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getEmails_0RequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getEmails_0
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun getEmails_0RequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/email".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get External Paths
    * Get details about your site&#39;s external path configs
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getExternalPaths(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = getExternalPathsWithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get External Paths
    * Get details about your site&#39;s external path configs
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getExternalPathsWithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getExternalPathsRequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getExternalPaths
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun getExternalPathsRequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/external-path".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get External Paths
    * Get details about your site&#39;s external path configs
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getExternalPaths_0(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = getExternalPaths_0WithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get External Paths
    * Get details about your site&#39;s external path configs
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getExternalPaths_0WithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getExternalPaths_0RequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getExternalPaths_0
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun getExternalPaths_0RequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/external-path".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * PIT Files
    * Get a list of wp-content files at a point in time
    * @param fqdn  
    * @param restorePoint  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFilesAtPoint(fqdn: kotlin.String, restorePoint: java.time.OffsetDateTime) : kotlin.Any {
        val localVarResponse = getFilesAtPointWithHttpInfo(fqdn = fqdn, restorePoint = restorePoint)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * PIT Files
    * Get a list of wp-content files at a point in time
    * @param fqdn  
    * @param restorePoint  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFilesAtPointWithHttpInfo(fqdn: kotlin.String, restorePoint: java.time.OffsetDateTime) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getFilesAtPointRequestConfig(fqdn = fqdn, restorePoint = restorePoint)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getFilesAtPoint
    *
    * @param fqdn  
    * @param restorePoint  
    * @return RequestConfig
    */
    fun getFilesAtPointRequestConfig(fqdn: kotlin.String, restorePoint: java.time.OffsetDateTime) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("restore_point", listOf(parseDateToQueryString(restorePoint)))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/pit-restore/files".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * PIT Files
    * Get a list of wp-content files at a point in time
    * @param fqdn  
    * @param restorePoint  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFilesAtPoint_0(fqdn: kotlin.String, restorePoint: java.time.OffsetDateTime) : kotlin.Any {
        val localVarResponse = getFilesAtPoint_0WithHttpInfo(fqdn = fqdn, restorePoint = restorePoint)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * PIT Files
    * Get a list of wp-content files at a point in time
    * @param fqdn  
    * @param restorePoint  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFilesAtPoint_0WithHttpInfo(fqdn: kotlin.String, restorePoint: java.time.OffsetDateTime) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getFilesAtPoint_0RequestConfig(fqdn = fqdn, restorePoint = restorePoint)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getFilesAtPoint_0
    *
    * @param fqdn  
    * @param restorePoint  
    * @return RequestConfig
    */
    fun getFilesAtPoint_0RequestConfig(fqdn: kotlin.String, restorePoint: java.time.OffsetDateTime) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("restore_point", listOf(parseDateToQueryString(restorePoint)))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/pit-restore/files".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Required mail DNS records
    * Get the required records for our custom email service
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMailDns(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = getMailDnsWithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get Required mail DNS records
    * Get the required records for our custom email service
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMailDnsWithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getMailDnsRequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getMailDns
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun getMailDnsRequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/dns/email_dns_records".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Required mail DNS records
    * Get the required records for our custom email service
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMailDns_0(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = getMailDns_0WithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get Required mail DNS records
    * Get the required records for our custom email service
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMailDns_0WithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getMailDns_0RequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getMailDns_0
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun getMailDns_0RequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/dns/email_dns_records".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get PIT Restore
    * Get the results of a site&#39;s restore to a previous point in time
    * @param pitRestoreId  
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPitRestore(pitRestoreId: kotlin.String, fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = getPitRestoreWithHttpInfo(pitRestoreId = pitRestoreId, fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get PIT Restore
    * Get the results of a site&#39;s restore to a previous point in time
    * @param pitRestoreId  
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPitRestoreWithHttpInfo(pitRestoreId: kotlin.String, fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getPitRestoreRequestConfig(pitRestoreId = pitRestoreId, fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getPitRestore
    *
    * @param pitRestoreId  
    * @param fqdn  
    * @return RequestConfig
    */
    fun getPitRestoreRequestConfig(pitRestoreId: kotlin.String, fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/pit-restore/{pit_restore_id}".replace("{"+"pit_restore_id"+"}", "$pitRestoreId").replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get PIT Restore
    * Get the results of a site&#39;s restore to a previous point in time
    * @param pitRestoreId  
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPitRestore_0(pitRestoreId: kotlin.String, fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = getPitRestore_0WithHttpInfo(pitRestoreId = pitRestoreId, fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get PIT Restore
    * Get the results of a site&#39;s restore to a previous point in time
    * @param pitRestoreId  
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPitRestore_0WithHttpInfo(pitRestoreId: kotlin.String, fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getPitRestore_0RequestConfig(pitRestoreId = pitRestoreId, fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getPitRestore_0
    *
    * @param pitRestoreId  
    * @param fqdn  
    * @return RequestConfig
    */
    fun getPitRestore_0RequestConfig(pitRestoreId: kotlin.String, fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/pit-restore/{pit_restore_id}".replace("{"+"pit_restore_id"+"}", "$pitRestoreId").replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get PIT Restores
    * Get all the results of a site&#39;s restores to a previous point in time
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPitRestores(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = getPitRestoresWithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get PIT Restores
    * Get all the results of a site&#39;s restores to a previous point in time
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPitRestoresWithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getPitRestoresRequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getPitRestores
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun getPitRestoresRequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/pit-restore".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get PIT Restores
    * Get all the results of a site&#39;s restores to a previous point in time
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPitRestores_0(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = getPitRestores_0WithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get PIT Restores
    * Get all the results of a site&#39;s restores to a previous point in time
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPitRestores_0WithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getPitRestores_0RequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getPitRestores_0
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun getPitRestores_0RequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/pit-restore".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get your live site
    * Get details about your live site
    * @param fqdn  
    * @return SiteLive
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSiteLive(fqdn: kotlin.String) : SiteLive {
        val localVarResponse = getSiteLiveWithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SiteLive
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get your live site
    * Get details about your live site
    * @param fqdn  
    * @return ApiResponse<SiteLive?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSiteLiveWithHttpInfo(fqdn: kotlin.String) : ApiResponse<SiteLive?> {
        val localVariableConfig = getSiteLiveRequestConfig(fqdn = fqdn)

        return request<Unit, SiteLive>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getSiteLive
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun getSiteLiveRequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get your live site
    * Get details about your live site
    * @param fqdn  
    * @return SiteLive
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSiteLive_0(fqdn: kotlin.String) : SiteLive {
        val localVarResponse = getSiteLive_0WithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SiteLive
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get your live site
    * Get details about your live site
    * @param fqdn  
    * @return ApiResponse<SiteLive?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSiteLive_0WithHttpInfo(fqdn: kotlin.String) : ApiResponse<SiteLive?> {
        val localVariableConfig = getSiteLive_0RequestConfig(fqdn = fqdn)

        return request<Unit, SiteLive>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getSiteLive_0
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun getSiteLive_0RequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Site Plan Usage
    * Get your visits and storage for a site at a given interval
    * @param fqdn  
    * @param start  
    * @param end  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSitePlanUsage(fqdn: kotlin.String, start: java.time.OffsetDateTime, end: java.time.OffsetDateTime) : kotlin.Any {
        val localVarResponse = getSitePlanUsageWithHttpInfo(fqdn = fqdn, start = start, end = end)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get Site Plan Usage
    * Get your visits and storage for a site at a given interval
    * @param fqdn  
    * @param start  
    * @param end  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSitePlanUsageWithHttpInfo(fqdn: kotlin.String, start: java.time.OffsetDateTime, end: java.time.OffsetDateTime) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getSitePlanUsageRequestConfig(fqdn = fqdn, start = start, end = end)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getSitePlanUsage
    *
    * @param fqdn  
    * @param start  
    * @param end  
    * @return RequestConfig
    */
    fun getSitePlanUsageRequestConfig(fqdn: kotlin.String, start: java.time.OffsetDateTime, end: java.time.OffsetDateTime) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("start", listOf(parseDateToQueryString(start)))
                put("end", listOf(parseDateToQueryString(end)))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/usage".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Site Plan Usage
    * Get your visits and storage for a site at a given interval
    * @param fqdn  
    * @param start  
    * @param end  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSitePlanUsage_0(fqdn: kotlin.String, start: java.time.OffsetDateTime, end: java.time.OffsetDateTime) : kotlin.Any {
        val localVarResponse = getSitePlanUsage_0WithHttpInfo(fqdn = fqdn, start = start, end = end)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get Site Plan Usage
    * Get your visits and storage for a site at a given interval
    * @param fqdn  
    * @param start  
    * @param end  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSitePlanUsage_0WithHttpInfo(fqdn: kotlin.String, start: java.time.OffsetDateTime, end: java.time.OffsetDateTime) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getSitePlanUsage_0RequestConfig(fqdn = fqdn, start = start, end = end)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getSitePlanUsage_0
    *
    * @param fqdn  
    * @param start  
    * @param end  
    * @return RequestConfig
    */
    fun getSitePlanUsage_0RequestConfig(fqdn: kotlin.String, start: java.time.OffsetDateTime, end: java.time.OffsetDateTime) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("start", listOf(parseDateToQueryString(start)))
                put("end", listOf(parseDateToQueryString(end)))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/usage".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get your sites
    * Get details about all of your live sites
    * @return kotlin.collections.List<SiteLive>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSitesLive() : kotlin.collections.List<SiteLive> {
        val localVarResponse = getSitesLiveWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SiteLive>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get your sites
    * Get details about all of your live sites
    * @return ApiResponse<kotlin.collections.List<SiteLive>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSitesLiveWithHttpInfo() : ApiResponse<kotlin.collections.List<SiteLive>?> {
        val localVariableConfig = getSitesLiveRequestConfig()

        return request<Unit, kotlin.collections.List<SiteLive>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getSitesLive
    *
    * @return RequestConfig
    */
    fun getSitesLiveRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get your sites
    * Get details about all of your live sites
    * @return kotlin.collections.List<SiteLive>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSitesLive_0() : kotlin.collections.List<SiteLive> {
        val localVarResponse = getSitesLive_0WithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SiteLive>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get your sites
    * Get details about all of your live sites
    * @return ApiResponse<kotlin.collections.List<SiteLive>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSitesLive_0WithHttpInfo() : ApiResponse<kotlin.collections.List<SiteLive>?> {
        val localVariableConfig = getSitesLive_0RequestConfig()

        return request<Unit, kotlin.collections.List<SiteLive>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getSitesLive_0
    *
    * @return RequestConfig
    */
    fun getSitesLive_0RequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get tags
    * Get all the tags for your site
    * @param fqdn  
    * @return kotlin.collections.List<Tag>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTags(fqdn: kotlin.String) : kotlin.collections.List<Tag> {
        val localVarResponse = getTagsWithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Tag>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get tags
    * Get all the tags for your site
    * @param fqdn  
    * @return ApiResponse<kotlin.collections.List<Tag>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTagsWithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.collections.List<Tag>?> {
        val localVariableConfig = getTagsRequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.collections.List<Tag>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getTags
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun getTagsRequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/tag".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get tags
    * Get all the tags for your site
    * @param fqdn  
    * @return kotlin.collections.List<Tag>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTags_0(fqdn: kotlin.String) : kotlin.collections.List<Tag> {
        val localVarResponse = getTags_0WithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Tag>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get tags
    * Get all the tags for your site
    * @param fqdn  
    * @return ApiResponse<kotlin.collections.List<Tag>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTags_0WithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.collections.List<Tag>?> {
        val localVariableConfig = getTags_0RequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.collections.List<Tag>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getTags_0
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun getTags_0RequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/tag".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Modify the firewall
    * Add/Delete an IP from the wp-login firewall
    * @param fqdn  
    * @param ipAddress  
    * @param addOrDel  (optional, default to "add")
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun modifyFirewall(fqdn: kotlin.String, ipAddress: kotlin.String, addOrDel: kotlin.String?) : kotlin.Any {
        val localVarResponse = modifyFirewallWithHttpInfo(fqdn = fqdn, ipAddress = ipAddress, addOrDel = addOrDel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Modify the firewall
    * Add/Delete an IP from the wp-login firewall
    * @param fqdn  
    * @param ipAddress  
    * @param addOrDel  (optional, default to "add")
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun modifyFirewallWithHttpInfo(fqdn: kotlin.String, ipAddress: kotlin.String, addOrDel: kotlin.String?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = modifyFirewallRequestConfig(fqdn = fqdn, ipAddress = ipAddress, addOrDel = addOrDel)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation modifyFirewall
    *
    * @param fqdn  
    * @param ipAddress  
    * @param addOrDel  (optional, default to "add")
    * @return RequestConfig
    */
    fun modifyFirewallRequestConfig(fqdn: kotlin.String, ipAddress: kotlin.String, addOrDel: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (addOrDel != null) {
                    put("add_or_del", listOf(addOrDel.toString()))
                }
                put("ip_address", listOf(ipAddress.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/site_live/{fqdn}/firewall".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Modify the firewall
    * Add/Delete an IP from the wp-login firewall
    * @param fqdn  
    * @param ipAddress  
    * @param addOrDel  (optional, default to "add")
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun modifyFirewall_0(fqdn: kotlin.String, ipAddress: kotlin.String, addOrDel: kotlin.String?) : kotlin.Any {
        val localVarResponse = modifyFirewall_0WithHttpInfo(fqdn = fqdn, ipAddress = ipAddress, addOrDel = addOrDel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Modify the firewall
    * Add/Delete an IP from the wp-login firewall
    * @param fqdn  
    * @param ipAddress  
    * @param addOrDel  (optional, default to "add")
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun modifyFirewall_0WithHttpInfo(fqdn: kotlin.String, ipAddress: kotlin.String, addOrDel: kotlin.String?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = modifyFirewall_0RequestConfig(fqdn = fqdn, ipAddress = ipAddress, addOrDel = addOrDel)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation modifyFirewall_0
    *
    * @param fqdn  
    * @param ipAddress  
    * @param addOrDel  (optional, default to "add")
    * @return RequestConfig
    */
    fun modifyFirewall_0RequestConfig(fqdn: kotlin.String, ipAddress: kotlin.String, addOrDel: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (addOrDel != null) {
                    put("add_or_del", listOf(addOrDel.toString()))
                }
                put("ip_address", listOf(ipAddress.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/site_live/{fqdn}/firewall".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create PIT Restore
    * Restore your site to a previous point in time, down to the minute
    * @param fqdn  
    * @param piTRestoreCreate  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun restoreSite(fqdn: kotlin.String, piTRestoreCreate: PITRestoreCreate) : kotlin.Any {
        val localVarResponse = restoreSiteWithHttpInfo(fqdn = fqdn, piTRestoreCreate = piTRestoreCreate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create PIT Restore
    * Restore your site to a previous point in time, down to the minute
    * @param fqdn  
    * @param piTRestoreCreate  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun restoreSiteWithHttpInfo(fqdn: kotlin.String, piTRestoreCreate: PITRestoreCreate) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = restoreSiteRequestConfig(fqdn = fqdn, piTRestoreCreate = piTRestoreCreate)

        return request<PITRestoreCreate, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation restoreSite
    *
    * @param fqdn  
    * @param piTRestoreCreate  
    * @return RequestConfig
    */
    fun restoreSiteRequestConfig(fqdn: kotlin.String, piTRestoreCreate: PITRestoreCreate) : RequestConfig<PITRestoreCreate> {
        val localVariableBody = piTRestoreCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/pit-restore".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create PIT Restore
    * Restore your site to a previous point in time, down to the minute
    * @param fqdn  
    * @param piTRestoreCreate  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun restoreSite_0(fqdn: kotlin.String, piTRestoreCreate: PITRestoreCreate) : kotlin.Any {
        val localVarResponse = restoreSite_0WithHttpInfo(fqdn = fqdn, piTRestoreCreate = piTRestoreCreate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create PIT Restore
    * Restore your site to a previous point in time, down to the minute
    * @param fqdn  
    * @param piTRestoreCreate  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun restoreSite_0WithHttpInfo(fqdn: kotlin.String, piTRestoreCreate: PITRestoreCreate) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = restoreSite_0RequestConfig(fqdn = fqdn, piTRestoreCreate = piTRestoreCreate)

        return request<PITRestoreCreate, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation restoreSite_0
    *
    * @param fqdn  
    * @param piTRestoreCreate  
    * @return RequestConfig
    */
    fun restoreSite_0RequestConfig(fqdn: kotlin.String, piTRestoreCreate: PITRestoreCreate) : RequestConfig<PITRestoreCreate> {
        val localVariableBody = piTRestoreCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/site_live/{fqdn}/pit-restore".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Execute shell command
    * Send a bash shell command to your site, such as a WP-CLI command
    * @param fqdn  
    * @param cmd  
    * @param cwd  (optional, default to "/bitnami/wordpress/wp-content")
    * @param autoTrackDir  (optional, default to false)
    * @param stage  (optional, default to false)
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun shellCmdSiteLive(fqdn: kotlin.String, cmd: kotlin.String, cwd: kotlin.String?, autoTrackDir: kotlin.Boolean?, stage: kotlin.Boolean?) : kotlin.Any {
        val localVarResponse = shellCmdSiteLiveWithHttpInfo(fqdn = fqdn, cmd = cmd, cwd = cwd, autoTrackDir = autoTrackDir, stage = stage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Execute shell command
    * Send a bash shell command to your site, such as a WP-CLI command
    * @param fqdn  
    * @param cmd  
    * @param cwd  (optional, default to "/bitnami/wordpress/wp-content")
    * @param autoTrackDir  (optional, default to false)
    * @param stage  (optional, default to false)
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun shellCmdSiteLiveWithHttpInfo(fqdn: kotlin.String, cmd: kotlin.String, cwd: kotlin.String?, autoTrackDir: kotlin.Boolean?, stage: kotlin.Boolean?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = shellCmdSiteLiveRequestConfig(fqdn = fqdn, cmd = cmd, cwd = cwd, autoTrackDir = autoTrackDir, stage = stage)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation shellCmdSiteLive
    *
    * @param fqdn  
    * @param cmd  
    * @param cwd  (optional, default to "/bitnami/wordpress/wp-content")
    * @param autoTrackDir  (optional, default to false)
    * @param stage  (optional, default to false)
    * @return RequestConfig
    */
    fun shellCmdSiteLiveRequestConfig(fqdn: kotlin.String, cmd: kotlin.String, cwd: kotlin.String?, autoTrackDir: kotlin.Boolean?, stage: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("cmd", listOf(cmd.toString()))
                if (cwd != null) {
                    put("cwd", listOf(cwd.toString()))
                }
                if (autoTrackDir != null) {
                    put("auto_track_dir", listOf(autoTrackDir.toString()))
                }
                if (stage != null) {
                    put("stage", listOf(stage.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/site_live/{fqdn}/cmd".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Execute shell command
    * Send a bash shell command to your site, such as a WP-CLI command
    * @param fqdn  
    * @param cmd  
    * @param cwd  (optional, default to "/bitnami/wordpress/wp-content")
    * @param autoTrackDir  (optional, default to false)
    * @param stage  (optional, default to false)
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun shellCmdSiteLive_0(fqdn: kotlin.String, cmd: kotlin.String, cwd: kotlin.String?, autoTrackDir: kotlin.Boolean?, stage: kotlin.Boolean?) : kotlin.Any {
        val localVarResponse = shellCmdSiteLive_0WithHttpInfo(fqdn = fqdn, cmd = cmd, cwd = cwd, autoTrackDir = autoTrackDir, stage = stage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Execute shell command
    * Send a bash shell command to your site, such as a WP-CLI command
    * @param fqdn  
    * @param cmd  
    * @param cwd  (optional, default to "/bitnami/wordpress/wp-content")
    * @param autoTrackDir  (optional, default to false)
    * @param stage  (optional, default to false)
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun shellCmdSiteLive_0WithHttpInfo(fqdn: kotlin.String, cmd: kotlin.String, cwd: kotlin.String?, autoTrackDir: kotlin.Boolean?, stage: kotlin.Boolean?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = shellCmdSiteLive_0RequestConfig(fqdn = fqdn, cmd = cmd, cwd = cwd, autoTrackDir = autoTrackDir, stage = stage)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation shellCmdSiteLive_0
    *
    * @param fqdn  
    * @param cmd  
    * @param cwd  (optional, default to "/bitnami/wordpress/wp-content")
    * @param autoTrackDir  (optional, default to false)
    * @param stage  (optional, default to false)
    * @return RequestConfig
    */
    fun shellCmdSiteLive_0RequestConfig(fqdn: kotlin.String, cmd: kotlin.String, cwd: kotlin.String?, autoTrackDir: kotlin.Boolean?, stage: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("cmd", listOf(cmd.toString()))
                if (cwd != null) {
                    put("cwd", listOf(cwd.toString()))
                }
                if (autoTrackDir != null) {
                    put("auto_track_dir", listOf(autoTrackDir.toString()))
                }
                if (stage != null) {
                    put("stage", listOf(stage.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/site_live/{fqdn}/cmd".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Update DNS record
    * Update a DNS record on your Nameserver configured site
    * @param fqdn  
    * @param dnsType  
    * @param dnsHostname  
    * @param dnsContent  
    * @param dnsId  (optional)
    * @param dnsPriority  (optional, default to 0)
    * @param dnsTtl  (optional, default to 1)
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateDnsRecord(fqdn: kotlin.String, dnsType: kotlin.String, dnsHostname: kotlin.String, dnsContent: kotlin.String, dnsId: kotlin.String?, dnsPriority: kotlin.Int?, dnsTtl: kotlin.Int?) : kotlin.Any {
        val localVarResponse = updateDnsRecordWithHttpInfo(fqdn = fqdn, dnsType = dnsType, dnsHostname = dnsHostname, dnsContent = dnsContent, dnsId = dnsId, dnsPriority = dnsPriority, dnsTtl = dnsTtl)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Update DNS record
    * Update a DNS record on your Nameserver configured site
    * @param fqdn  
    * @param dnsType  
    * @param dnsHostname  
    * @param dnsContent  
    * @param dnsId  (optional)
    * @param dnsPriority  (optional, default to 0)
    * @param dnsTtl  (optional, default to 1)
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateDnsRecordWithHttpInfo(fqdn: kotlin.String, dnsType: kotlin.String, dnsHostname: kotlin.String, dnsContent: kotlin.String, dnsId: kotlin.String?, dnsPriority: kotlin.Int?, dnsTtl: kotlin.Int?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = updateDnsRecordRequestConfig(fqdn = fqdn, dnsType = dnsType, dnsHostname = dnsHostname, dnsContent = dnsContent, dnsId = dnsId, dnsPriority = dnsPriority, dnsTtl = dnsTtl)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation updateDnsRecord
    *
    * @param fqdn  
    * @param dnsType  
    * @param dnsHostname  
    * @param dnsContent  
    * @param dnsId  (optional)
    * @param dnsPriority  (optional, default to 0)
    * @param dnsTtl  (optional, default to 1)
    * @return RequestConfig
    */
    fun updateDnsRecordRequestConfig(fqdn: kotlin.String, dnsType: kotlin.String, dnsHostname: kotlin.String, dnsContent: kotlin.String, dnsId: kotlin.String?, dnsPriority: kotlin.Int?, dnsTtl: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("dns_type", listOf(dnsType.toString()))
                put("dns_hostname", listOf(dnsHostname.toString()))
                put("dns_content", listOf(dnsContent.toString()))
                if (dnsId != null) {
                    put("dns_id", listOf(dnsId.toString()))
                }
                if (dnsPriority != null) {
                    put("dns_priority", listOf(dnsPriority.toString()))
                }
                if (dnsTtl != null) {
                    put("dns_ttl", listOf(dnsTtl.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/site_live/{fqdn}/dns".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Update DNS record
    * Update a DNS record on your Nameserver configured site
    * @param fqdn  
    * @param dnsType  
    * @param dnsHostname  
    * @param dnsContent  
    * @param dnsId  (optional)
    * @param dnsPriority  (optional, default to 0)
    * @param dnsTtl  (optional, default to 1)
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateDnsRecord_0(fqdn: kotlin.String, dnsType: kotlin.String, dnsHostname: kotlin.String, dnsContent: kotlin.String, dnsId: kotlin.String?, dnsPriority: kotlin.Int?, dnsTtl: kotlin.Int?) : kotlin.Any {
        val localVarResponse = updateDnsRecord_0WithHttpInfo(fqdn = fqdn, dnsType = dnsType, dnsHostname = dnsHostname, dnsContent = dnsContent, dnsId = dnsId, dnsPriority = dnsPriority, dnsTtl = dnsTtl)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Update DNS record
    * Update a DNS record on your Nameserver configured site
    * @param fqdn  
    * @param dnsType  
    * @param dnsHostname  
    * @param dnsContent  
    * @param dnsId  (optional)
    * @param dnsPriority  (optional, default to 0)
    * @param dnsTtl  (optional, default to 1)
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateDnsRecord_0WithHttpInfo(fqdn: kotlin.String, dnsType: kotlin.String, dnsHostname: kotlin.String, dnsContent: kotlin.String, dnsId: kotlin.String?, dnsPriority: kotlin.Int?, dnsTtl: kotlin.Int?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = updateDnsRecord_0RequestConfig(fqdn = fqdn, dnsType = dnsType, dnsHostname = dnsHostname, dnsContent = dnsContent, dnsId = dnsId, dnsPriority = dnsPriority, dnsTtl = dnsTtl)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation updateDnsRecord_0
    *
    * @param fqdn  
    * @param dnsType  
    * @param dnsHostname  
    * @param dnsContent  
    * @param dnsId  (optional)
    * @param dnsPriority  (optional, default to 0)
    * @param dnsTtl  (optional, default to 1)
    * @return RequestConfig
    */
    fun updateDnsRecord_0RequestConfig(fqdn: kotlin.String, dnsType: kotlin.String, dnsHostname: kotlin.String, dnsContent: kotlin.String, dnsId: kotlin.String?, dnsPriority: kotlin.Int?, dnsTtl: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("dns_type", listOf(dnsType.toString()))
                put("dns_hostname", listOf(dnsHostname.toString()))
                put("dns_content", listOf(dnsContent.toString()))
                if (dnsId != null) {
                    put("dns_id", listOf(dnsId.toString()))
                }
                if (dnsPriority != null) {
                    put("dns_priority", listOf(dnsPriority.toString()))
                }
                if (dnsTtl != null) {
                    put("dns_ttl", listOf(dnsTtl.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/site_live/{fqdn}/dns".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Update Email
    * Update a custom email account
    * @param userEmailAddress  
    * @param fqdn  
    * @param userEmailUpdate  (optional)
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateEmail(userEmailAddress: kotlin.String, fqdn: kotlin.String, userEmailUpdate: UserEmailUpdate?) : kotlin.Any {
        val localVarResponse = updateEmailWithHttpInfo(userEmailAddress = userEmailAddress, fqdn = fqdn, userEmailUpdate = userEmailUpdate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Update Email
    * Update a custom email account
    * @param userEmailAddress  
    * @param fqdn  
    * @param userEmailUpdate  (optional)
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateEmailWithHttpInfo(userEmailAddress: kotlin.String, fqdn: kotlin.String, userEmailUpdate: UserEmailUpdate?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = updateEmailRequestConfig(userEmailAddress = userEmailAddress, fqdn = fqdn, userEmailUpdate = userEmailUpdate)

        return request<UserEmailUpdate, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation updateEmail
    *
    * @param userEmailAddress  
    * @param fqdn  
    * @param userEmailUpdate  (optional)
    * @return RequestConfig
    */
    fun updateEmailRequestConfig(userEmailAddress: kotlin.String, fqdn: kotlin.String, userEmailUpdate: UserEmailUpdate?) : RequestConfig<UserEmailUpdate> {
        val localVariableBody = userEmailUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v1/site_live/{fqdn}/email/{user_email_address}".replace("{"+"user_email_address"+"}", "$userEmailAddress").replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Update Email
    * Update a custom email account
    * @param userEmailAddress  
    * @param fqdn  
    * @param userEmailUpdate  (optional)
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateEmail_0(userEmailAddress: kotlin.String, fqdn: kotlin.String, userEmailUpdate: UserEmailUpdate?) : kotlin.Any {
        val localVarResponse = updateEmail_0WithHttpInfo(userEmailAddress = userEmailAddress, fqdn = fqdn, userEmailUpdate = userEmailUpdate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Update Email
    * Update a custom email account
    * @param userEmailAddress  
    * @param fqdn  
    * @param userEmailUpdate  (optional)
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateEmail_0WithHttpInfo(userEmailAddress: kotlin.String, fqdn: kotlin.String, userEmailUpdate: UserEmailUpdate?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = updateEmail_0RequestConfig(userEmailAddress = userEmailAddress, fqdn = fqdn, userEmailUpdate = userEmailUpdate)

        return request<UserEmailUpdate, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation updateEmail_0
    *
    * @param userEmailAddress  
    * @param fqdn  
    * @param userEmailUpdate  (optional)
    * @return RequestConfig
    */
    fun updateEmail_0RequestConfig(userEmailAddress: kotlin.String, fqdn: kotlin.String, userEmailUpdate: UserEmailUpdate?) : RequestConfig<UserEmailUpdate> {
        val localVariableBody = userEmailUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v1/site_live/{fqdn}/email/{user_email_address}".replace("{"+"user_email_address"+"}", "$userEmailAddress").replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Update a site
    * Update a site&#39;s details
    * @param fqdn  
    * @param siteLiveUpdate  
    * @return SiteLive
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateSiteLive(fqdn: kotlin.String, siteLiveUpdate: SiteLiveUpdate) : SiteLive {
        val localVarResponse = updateSiteLiveWithHttpInfo(fqdn = fqdn, siteLiveUpdate = siteLiveUpdate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SiteLive
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Update a site
    * Update a site&#39;s details
    * @param fqdn  
    * @param siteLiveUpdate  
    * @return ApiResponse<SiteLive?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateSiteLiveWithHttpInfo(fqdn: kotlin.String, siteLiveUpdate: SiteLiveUpdate) : ApiResponse<SiteLive?> {
        val localVariableConfig = updateSiteLiveRequestConfig(fqdn = fqdn, siteLiveUpdate = siteLiveUpdate)

        return request<SiteLiveUpdate, SiteLive>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation updateSiteLive
    *
    * @param fqdn  
    * @param siteLiveUpdate  
    * @return RequestConfig
    */
    fun updateSiteLiveRequestConfig(fqdn: kotlin.String, siteLiveUpdate: SiteLiveUpdate) : RequestConfig<SiteLiveUpdate> {
        val localVariableBody = siteLiveUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/site_live/{fqdn}".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Update a site
    * Update a site&#39;s details
    * @param fqdn  
    * @param siteLiveUpdate  
    * @return SiteLive
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateSiteLive_0(fqdn: kotlin.String, siteLiveUpdate: SiteLiveUpdate) : SiteLive {
        val localVarResponse = updateSiteLive_0WithHttpInfo(fqdn = fqdn, siteLiveUpdate = siteLiveUpdate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SiteLive
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Update a site
    * Update a site&#39;s details
    * @param fqdn  
    * @param siteLiveUpdate  
    * @return ApiResponse<SiteLive?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateSiteLive_0WithHttpInfo(fqdn: kotlin.String, siteLiveUpdate: SiteLiveUpdate) : ApiResponse<SiteLive?> {
        val localVariableConfig = updateSiteLive_0RequestConfig(fqdn = fqdn, siteLiveUpdate = siteLiveUpdate)

        return request<SiteLiveUpdate, SiteLive>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation updateSiteLive_0
    *
    * @param fqdn  
    * @param siteLiveUpdate  
    * @return RequestConfig
    */
    fun updateSiteLive_0RequestConfig(fqdn: kotlin.String, siteLiveUpdate: SiteLiveUpdate) : RequestConfig<SiteLiveUpdate> {
        val localVariableBody = siteLiveUpdate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/site_live/{fqdn}".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * MX Validation
    * Check if your mail related DNS records are set up correctly
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun validateMxRecords(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = validateMxRecordsWithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * MX Validation
    * Check if your mail related DNS records are set up correctly
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun validateMxRecordsWithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = validateMxRecordsRequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation validateMxRecords
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun validateMxRecordsRequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/validate_mx_records".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * MX Validation
    * Check if your mail related DNS records are set up correctly
    * @param fqdn  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun validateMxRecords_0(fqdn: kotlin.String) : kotlin.Any {
        val localVarResponse = validateMxRecords_0WithHttpInfo(fqdn = fqdn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * MX Validation
    * Check if your mail related DNS records are set up correctly
    * @param fqdn  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun validateMxRecords_0WithHttpInfo(fqdn: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = validateMxRecords_0RequestConfig(fqdn = fqdn)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation validateMxRecords_0
    *
    * @param fqdn  
    * @return RequestConfig
    */
    fun validateMxRecords_0RequestConfig(fqdn: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/site_live/{fqdn}/validate_mx_records".replace("{"+"fqdn"+"}", "$fqdn"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
