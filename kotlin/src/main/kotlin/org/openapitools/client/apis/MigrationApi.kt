/**
 * Site Bay
 *
 * OpenAPI schema for the Agency plan. Access for only $99USD per month! Swagger docs available at https://my.sitebay.org/docs
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException

import org.openapitools.client.models.HTTPValidationError
import org.openapitools.client.models.Migration

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class MigrationApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://my.sitebay.org")
        }
    }

    /**
    * Create a migration
    * Request a new site migration by providing your old host&#39;s domain and your site&#39;s login details
    * @param currentUrl  
    * @param wordpressPassword  
    * @param wordpressUser  
    * @param extra  (optional)
    * @param ftpAddress  (optional)
    * @param ftpPassword  (optional)
    * @param ftpUser  (optional)
    * @param host  (optional)
    * @param hostPassword  (optional)
    * @param hostUser  (optional)
    * @param migrationType  (optional)
    * @param zipFile  (optional)
    * @param zipFileName  (optional)
    * @return Migration
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createMigration(currentUrl: kotlin.String, wordpressPassword: kotlin.String, wordpressUser: kotlin.String, extra: kotlin.String?, ftpAddress: kotlin.String?, ftpPassword: kotlin.String?, ftpUser: kotlin.String?, host: kotlin.String?, hostPassword: kotlin.String?, hostUser: kotlin.String?, migrationType: kotlin.String?, zipFile: java.io.File?, zipFileName: kotlin.String?) : Migration {
        val localVarResponse = createMigrationWithHttpInfo(currentUrl = currentUrl, wordpressPassword = wordpressPassword, wordpressUser = wordpressUser, extra = extra, ftpAddress = ftpAddress, ftpPassword = ftpPassword, ftpUser = ftpUser, host = host, hostPassword = hostPassword, hostUser = hostUser, migrationType = migrationType, zipFile = zipFile, zipFileName = zipFileName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Migration
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create a migration
    * Request a new site migration by providing your old host&#39;s domain and your site&#39;s login details
    * @param currentUrl  
    * @param wordpressPassword  
    * @param wordpressUser  
    * @param extra  (optional)
    * @param ftpAddress  (optional)
    * @param ftpPassword  (optional)
    * @param ftpUser  (optional)
    * @param host  (optional)
    * @param hostPassword  (optional)
    * @param hostUser  (optional)
    * @param migrationType  (optional)
    * @param zipFile  (optional)
    * @param zipFileName  (optional)
    * @return ApiResponse<Migration?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createMigrationWithHttpInfo(currentUrl: kotlin.String, wordpressPassword: kotlin.String, wordpressUser: kotlin.String, extra: kotlin.String?, ftpAddress: kotlin.String?, ftpPassword: kotlin.String?, ftpUser: kotlin.String?, host: kotlin.String?, hostPassword: kotlin.String?, hostUser: kotlin.String?, migrationType: kotlin.String?, zipFile: java.io.File?, zipFileName: kotlin.String?) : ApiResponse<Migration?> {
        val localVariableConfig = createMigrationRequestConfig(currentUrl = currentUrl, wordpressPassword = wordpressPassword, wordpressUser = wordpressUser, extra = extra, ftpAddress = ftpAddress, ftpPassword = ftpPassword, ftpUser = ftpUser, host = host, hostPassword = hostPassword, hostUser = hostUser, migrationType = migrationType, zipFile = zipFile, zipFileName = zipFileName)

        return request<Map<String, Any?>, Migration>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation createMigration
    *
    * @param currentUrl  
    * @param wordpressPassword  
    * @param wordpressUser  
    * @param extra  (optional)
    * @param ftpAddress  (optional)
    * @param ftpPassword  (optional)
    * @param ftpUser  (optional)
    * @param host  (optional)
    * @param hostPassword  (optional)
    * @param hostUser  (optional)
    * @param migrationType  (optional)
    * @param zipFile  (optional)
    * @param zipFileName  (optional)
    * @return RequestConfig
    */
    fun createMigrationRequestConfig(currentUrl: kotlin.String, wordpressPassword: kotlin.String, wordpressUser: kotlin.String, extra: kotlin.String?, ftpAddress: kotlin.String?, ftpPassword: kotlin.String?, ftpUser: kotlin.String?, host: kotlin.String?, hostPassword: kotlin.String?, hostUser: kotlin.String?, migrationType: kotlin.String?, zipFile: java.io.File?, zipFileName: kotlin.String?) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("current_url" to currentUrl, "extra" to extra, "ftp_address" to ftpAddress, "ftp_password" to ftpPassword, "ftp_user" to ftpUser, "host" to host, "host_password" to hostPassword, "host_user" to hostUser, "migration_type" to migrationType, "wordpress_password" to wordpressPassword, "wordpress_user" to wordpressUser, "zip_file" to zipFile, "zip_file_name" to zipFileName)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/migration",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delete Migration
    * 
    * @param migrationId  
    * @return kotlin.Any
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteMigration(migrationId: kotlin.Int) : kotlin.Any {
        val localVarResponse = deleteMigrationWithHttpInfo(migrationId = migrationId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Delete Migration
    * 
    * @param migrationId  
    * @return ApiResponse<kotlin.Any?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteMigrationWithHttpInfo(migrationId: kotlin.Int) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deleteMigrationRequestConfig(migrationId = migrationId)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deleteMigration
    *
    * @param migrationId  
    * @return RequestConfig
    */
    fun deleteMigrationRequestConfig(migrationId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/migration/{migration_id}".replace("{"+"migration_id"+"}", "$migrationId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Migrations
    * 
    * @return kotlin.collections.List<Migration>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMigrations() : kotlin.collections.List<Migration> {
        val localVarResponse = getMigrationsWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Migration>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get Migrations
    * 
    * @return ApiResponse<kotlin.collections.List<Migration>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMigrationsWithHttpInfo() : ApiResponse<kotlin.collections.List<Migration>?> {
        val localVariableConfig = getMigrationsRequestConfig()

        return request<Unit, kotlin.collections.List<Migration>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getMigrations
    *
    * @return RequestConfig
    */
    fun getMigrationsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/migration",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
