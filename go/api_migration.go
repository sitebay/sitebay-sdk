/*
Site Bay

OpenAPI schema for the Agency plan. Access for only $99USD per month! Swagger docs available at https://my.sitebay.org/docs

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"os"
)

// Linger please
var (
	_ context.Context
)

// MigrationApiService MigrationApi service
type MigrationApiService service

type ApiCreateMigrationRequest struct {
	ctx context.Context
	ApiService *MigrationApiService
	currentUrl *string
	wordpressPassword *string
	wordpressUser *string
	extra *string
	ftpAddress *string
	ftpPassword *string
	ftpUser *string
	host *string
	hostPassword *string
	hostUser *string
	migrationType *string
	zipFile **os.File
	zipFileName *string
}

func (r ApiCreateMigrationRequest) CurrentUrl(currentUrl string) ApiCreateMigrationRequest {
	r.currentUrl = &currentUrl
	return r
}
func (r ApiCreateMigrationRequest) WordpressPassword(wordpressPassword string) ApiCreateMigrationRequest {
	r.wordpressPassword = &wordpressPassword
	return r
}
func (r ApiCreateMigrationRequest) WordpressUser(wordpressUser string) ApiCreateMigrationRequest {
	r.wordpressUser = &wordpressUser
	return r
}
func (r ApiCreateMigrationRequest) Extra(extra string) ApiCreateMigrationRequest {
	r.extra = &extra
	return r
}
func (r ApiCreateMigrationRequest) FtpAddress(ftpAddress string) ApiCreateMigrationRequest {
	r.ftpAddress = &ftpAddress
	return r
}
func (r ApiCreateMigrationRequest) FtpPassword(ftpPassword string) ApiCreateMigrationRequest {
	r.ftpPassword = &ftpPassword
	return r
}
func (r ApiCreateMigrationRequest) FtpUser(ftpUser string) ApiCreateMigrationRequest {
	r.ftpUser = &ftpUser
	return r
}
func (r ApiCreateMigrationRequest) Host(host string) ApiCreateMigrationRequest {
	r.host = &host
	return r
}
func (r ApiCreateMigrationRequest) HostPassword(hostPassword string) ApiCreateMigrationRequest {
	r.hostPassword = &hostPassword
	return r
}
func (r ApiCreateMigrationRequest) HostUser(hostUser string) ApiCreateMigrationRequest {
	r.hostUser = &hostUser
	return r
}
func (r ApiCreateMigrationRequest) MigrationType(migrationType string) ApiCreateMigrationRequest {
	r.migrationType = &migrationType
	return r
}
func (r ApiCreateMigrationRequest) ZipFile(zipFile *os.File) ApiCreateMigrationRequest {
	r.zipFile = &zipFile
	return r
}
func (r ApiCreateMigrationRequest) ZipFileName(zipFileName string) ApiCreateMigrationRequest {
	r.zipFileName = &zipFileName
	return r
}

func (r ApiCreateMigrationRequest) Execute() (*Migration, *http.Response, error) {
	return r.ApiService.CreateMigrationExecute(r)
}

/*
CreateMigration Create a migration

Request a new site migration by providing your old host's domain and your site's login details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateMigrationRequest
*/
func (a *MigrationApiService) CreateMigration(ctx context.Context) ApiCreateMigrationRequest {
	return ApiCreateMigrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Migration
func (a *MigrationApiService) CreateMigrationExecute(r ApiCreateMigrationRequest) (*Migration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Migration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MigrationApiService.CreateMigration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/migration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.currentUrl == nil {
		return localVarReturnValue, nil, reportError("currentUrl is required and must be specified")
	}
	if r.wordpressPassword == nil {
		return localVarReturnValue, nil, reportError("wordpressPassword is required and must be specified")
	}
	if r.wordpressUser == nil {
		return localVarReturnValue, nil, reportError("wordpressUser is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("current_url", parameterToString(*r.currentUrl, ""))
	if r.extra != nil {
		localVarFormParams.Add("extra", parameterToString(*r.extra, ""))
	}
	if r.ftpAddress != nil {
		localVarFormParams.Add("ftp_address", parameterToString(*r.ftpAddress, ""))
	}
	if r.ftpPassword != nil {
		localVarFormParams.Add("ftp_password", parameterToString(*r.ftpPassword, ""))
	}
	if r.ftpUser != nil {
		localVarFormParams.Add("ftp_user", parameterToString(*r.ftpUser, ""))
	}
	if r.host != nil {
		localVarFormParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.hostPassword != nil {
		localVarFormParams.Add("host_password", parameterToString(*r.hostPassword, ""))
	}
	if r.hostUser != nil {
		localVarFormParams.Add("host_user", parameterToString(*r.hostUser, ""))
	}
	if r.migrationType != nil {
		localVarFormParams.Add("migration_type", parameterToString(*r.migrationType, ""))
	}
	localVarFormParams.Add("wordpress_password", parameterToString(*r.wordpressPassword, ""))
	localVarFormParams.Add("wordpress_user", parameterToString(*r.wordpressUser, ""))
	var zipFileLocalVarFormFileName string
	var zipFileLocalVarFileName     string
	var zipFileLocalVarFileBytes    []byte

	zipFileLocalVarFormFileName = "zip_file"

	var zipFileLocalVarFile *os.File
	if r.zipFile != nil {
		zipFileLocalVarFile = *r.zipFile
	}
	if zipFileLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(zipFileLocalVarFile)
		zipFileLocalVarFileBytes = fbs
		zipFileLocalVarFileName = zipFileLocalVarFile.Name()
		zipFileLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: zipFileLocalVarFileBytes, fileName: zipFileLocalVarFileName, formFileName: zipFileLocalVarFormFileName})
	if r.zipFileName != nil {
		localVarFormParams.Add("zip_file_name", parameterToString(*r.zipFileName, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMigrationRequest struct {
	ctx context.Context
	ApiService *MigrationApiService
	migrationId int32
}


func (r ApiDeleteMigrationRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteMigrationExecute(r)
}

/*
DeleteMigration Delete Migration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param migrationId
 @return ApiDeleteMigrationRequest
*/
func (a *MigrationApiService) DeleteMigration(ctx context.Context, migrationId int32) ApiDeleteMigrationRequest {
	return ApiDeleteMigrationRequest{
		ApiService: a,
		ctx: ctx,
		migrationId: migrationId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *MigrationApiService) DeleteMigrationExecute(r ApiDeleteMigrationRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MigrationApiService.DeleteMigration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/migration/{migration_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"migration_id"+"}", url.PathEscape(parameterToString(r.migrationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMigrationsRequest struct {
	ctx context.Context
	ApiService *MigrationApiService
}


func (r ApiGetMigrationsRequest) Execute() ([]Migration, *http.Response, error) {
	return r.ApiService.GetMigrationsExecute(r)
}

/*
GetMigrations Get Migrations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMigrationsRequest
*/
func (a *MigrationApiService) GetMigrations(ctx context.Context) ApiGetMigrationsRequest {
	return ApiGetMigrationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Migration
func (a *MigrationApiService) GetMigrationsExecute(r ApiGetMigrationsRequest) ([]Migration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Migration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MigrationApiService.GetMigrations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/migration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
